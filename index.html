<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>BODY PARTICLES — Pose-Driven GPU Particles</title>

<!-- OGP -->
<meta property="og:title" content="BODY PARTICLES">
<meta property="og:description" content="MediaPipe Pose Landmarkerで全身33点を検出し、WebGPU Compute Shaderで20万パーティクルをリアルタイム放出するインタラクティブ体験">
<meta property="og:image" content="https://paul13131313.github.io/body-particles/ogp.png">
<meta property="og:url" content="https://paul13131313.github.io/body-particles/">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">

<!-- Favicon -->
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='12' fill='%23000'/><circle cx='50' cy='30' r='8' fill='%23ff6b6b'/><line x1='50' y1='38' x2='50' y2='65' stroke='%234ecdc4' stroke-width='3'/><line x1='50' y1='45' x2='30' y2='55' stroke='%23ffe66d' stroke-width='2.5'/><line x1='50' y1='45' x2='70' y2='55' stroke='%23a855f7' stroke-width='2.5'/><line x1='50' y1='65' x2='35' y2='85' stroke='%23ff6b6b' stroke-width='2.5'/><line x1='50' y1='65' x2='65' y2='85' stroke='%234ecdc4' stroke-width='2.5'/><circle cx='30' cy='55' r='3' fill='%23ffe66d' opacity='0.8'/><circle cx='70' cy='55' r='3' fill='%23a855f7' opacity='0.8'/><circle cx='35' cy='85' r='3' fill='%23ff6b6b' opacity='0.8'/><circle cx='65' cy='85' r='3' fill='%234ecdc4' opacity='0.8'/></svg>">

<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000; color: #fff; overflow: hidden;
    font-family: 'Courier New', monospace;
    -webkit-user-select: none; user-select: none;
    touch-action: manipulation;
  }

  #gpuCanvas { display: block; width: 100vw; height: 100vh; }

  /* Start screen */
  .screen { position: fixed; inset: 0; display: none; z-index: 20; }
  .screen.active { display: flex; }

  #start-screen {
    flex-direction: column; align-items: center; justify-content: center;
    background: #000;
  }
  #start-screen::before {
    content: ''; position: absolute; inset: 0;
    background:
      repeating-linear-gradient(0deg, transparent, transparent 79px, rgba(255,255,255,0.03) 79px, rgba(255,255,255,0.03) 80px),
      repeating-linear-gradient(90deg, transparent, transparent 79px, rgba(255,255,255,0.03) 79px, rgba(255,255,255,0.03) 80px);
    pointer-events: none;
  }
  .start-title {
    font-size: 24px; letter-spacing: 8px; font-weight: 700;
    color: rgba(255,255,255,0.9); margin-bottom: 8px; position: relative;
  }
  .start-sub {
    font-size: 10px; letter-spacing: 3px;
    color: rgba(255,255,255,0.35); margin-bottom: 40px;
  }
  #start-btn {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.8);
    padding: 14px 40px; font-size: 12px; letter-spacing: 4px;
    font-family: 'Courier New', monospace;
    cursor: pointer; transition: all 0.3s; border-radius: 2px;
  }
  #start-btn:hover {
    background: rgba(255,255,255,0.15);
    border-color: rgba(255,255,255,0.4);
    color: #fff;
  }
  #start-btn:disabled {
    opacity: 0.3; cursor: default;
  }
  #loading-status {
    font-size: 10px; letter-spacing: 2px;
    color: rgba(255,255,255,0.3); margin-top: 20px;
    min-height: 16px;
  }

  /* Error screen */
  #error-screen {
    position: fixed; inset: 0;
    display: none; align-items: center; justify-content: center;
    background: #000; color: #fff; text-align: center;
    padding: 2em; z-index: 100;
  }
  #error-screen h2 { font-size: 16px; letter-spacing: 3px; margin-bottom: 16px; }
  #error-screen p { font-size: 12px; color: rgba(255,255,255,0.5); line-height: 1.8; }

  /* Title */
  #title-bar {
    position: fixed; top: 0; left: 0; right: 0;
    padding: 20px 24px;
    display: flex; justify-content: space-between; align-items: flex-start;
    pointer-events: none; z-index: 10;
  }
  .title-block h1 {
    font-size: 14px; font-weight: 700; letter-spacing: 4px;
    color: rgba(255,255,255,0.7);
  }
  .title-block .sub {
    font-size: 9px; letter-spacing: 2px;
    color: rgba(255,255,255,0.25); margin-top: 4px;
  }
  #fps {
    font-size: 10px; color: rgba(255,255,255,0.25);
    margin-top: 8px;
  }
  #mode-label {
    font-size: 12px; letter-spacing: 3px;
    color: rgba(255,255,255,0.5);
    pointer-events: auto;
  }

  /* Camera preview */
  #preview-wrap {
    position: fixed; bottom: 20px; left: 20px; z-index: 10;
    width: 200px; border-radius: 8px; overflow: hidden;
    border: 1px solid rgba(255,255,255,0.15);
    background: rgba(0,0,0,0.5);
  }
  #preview-canvas {
    display: block; width: 100%; height: auto;
  }

  /* Hint */
  #hint {
    position: fixed; bottom: 50%; left: 50%;
    transform: translate(-50%, 50%);
    font-size: 14px; letter-spacing: 4px;
    color: rgba(255,255,255,0.3);
    z-index: 10; pointer-events: none;
    transition: opacity 0.5s;
  }

  /* Controls panel */
  #controls {
    position: fixed; bottom: 20px; right: 20px; z-index: 10;
    background: rgba(0,0,0,0.7);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 4px; padding: 16px;
    min-width: 220px;
    transition: all 0.3s;
  }
  #controls.collapsed { padding: 8px 16px; min-width: auto; }
  #controls.collapsed .ctrl-body { display: none; }

  .ctrl-header {
    display: flex; justify-content: space-between; align-items: center;
    cursor: pointer; margin-bottom: 12px;
  }
  #controls.collapsed .ctrl-header { margin-bottom: 0; }
  .ctrl-header span {
    font-size: 10px; letter-spacing: 2px; color: rgba(255,255,255,0.5);
  }
  .ctrl-toggle {
    font-size: 10px; color: rgba(255,255,255,0.3);
    background: none; border: none; cursor: pointer;
    font-family: 'Courier New', monospace;
  }

  .ctrl-row {
    margin-bottom: 10px;
  }
  .ctrl-row:last-child { margin-bottom: 0; }
  .ctrl-row label {
    display: block; font-size: 9px; letter-spacing: 2px;
    color: rgba(255,255,255,0.35); margin-bottom: 4px;
  }

  .btn-group { display: flex; gap: 4px; }
  .mode-btn {
    flex: 1; padding: 5px 0; font-size: 9px; letter-spacing: 1px;
    font-family: 'Courier New', monospace;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    color: rgba(255,255,255,0.4);
    cursor: pointer; transition: all 0.2s; border-radius: 2px;
  }
  .mode-btn:hover { background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.7); }
  .mode-btn.active {
    background: rgba(255,255,255,0.15);
    border-color: rgba(255,255,255,0.35);
    color: #fff;
  }

  input[type="range"] {
    width: 100%; height: 2px; -webkit-appearance: none;
    background: rgba(255,255,255,0.15); outline: none;
    border-radius: 1px;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none; width: 10px; height: 10px;
    background: rgba(255,255,255,0.6); border-radius: 50%;
    cursor: pointer;
  }

  .hidden { display: none !important; }
</style>
</head>
<body>

<!-- Start screen -->
<div id="start-screen" class="screen active">
  <div class="start-title">BODY PARTICLES</div>
  <div class="start-sub">POSE-DRIVEN GPU PARTICLE EXPERIENCE</div>
  <button id="start-btn" disabled>INITIALIZING...</button>
  <div id="loading-status"></div>
</div>

<!-- Error screen -->
<div id="error-screen">
  <div>
    <h2>WebGPU NOT AVAILABLE</h2>
    <p>
      This experience requires WebGPU.<br>
      Please use Chrome 113+ or Edge 113+.<br><br>
      chrome://flags → "Unsafe WebGPU" → Enabled
    </p>
  </div>
</div>

<!-- Main canvas -->
<canvas id="gpuCanvas"></canvas>

<!-- Title bar -->
<div id="title-bar" class="hidden">
  <div class="title-block">
    <h1>BODY PARTICLES</h1>
    <div class="sub">POSE × WebGPU COMPUTE SHADER</div>
    <div id="fps"></div>
  </div>
  <div id="mode-label">AURA</div>
</div>

<!-- Camera preview -->
<div id="preview-wrap" class="hidden">
  <canvas id="preview-canvas"></canvas>
</div>

<!-- Hint -->
<div id="hint" class="hidden">STAND IN FRAME</div>

<!-- Controls -->
<div id="controls" class="hidden">
  <div class="ctrl-header" id="ctrl-toggle">
    <span>CONTROLS</span>
    <button class="ctrl-toggle">▼</button>
  </div>
  <div class="ctrl-body">
    <div class="ctrl-row">
      <label>EFFECT MODE</label>
      <div class="btn-group" id="mode-btns">
        <button class="mode-btn active" data-mode="0">AURA</button>
        <button class="mode-btn" data-mode="1">SPARK</button>
        <button class="mode-btn" data-mode="2">TRAIL</button>
      </div>
    </div>
    <div class="ctrl-row">
      <label>PARTICLES: <span id="particle-count-label">200K</span></label>
      <input type="range" id="particle-slider" min="50000" max="200000" step="10000" value="200000">
    </div>
    <div class="ctrl-row">
      <label>COLOR</label>
      <div class="btn-group" id="color-btns">
        <button class="mode-btn active" data-color="0">NEON</button>
        <button class="mode-btn" data-color="1">FIRE</button>
        <button class="mode-btn" data-color="2">ICE</button>
        <button class="mode-btn" data-color="3">RAINBOW</button>
      </div>
    </div>
    <div class="ctrl-row">
      <label>SIZE</label>
      <input type="range" id="size-slider" min="0.5" max="4.0" step="0.1" value="2.0">
    </div>
    <div class="ctrl-row">
      <label>GRAVITY</label>
      <input type="range" id="gravity-slider" min="0" max="3.0" step="0.1" value="0.5">
    </div>
    <div class="ctrl-row">
      <label>BACKGROUND</label>
      <div class="btn-group" id="bg-btns">
        <button class="mode-btn active" data-bg="0">BLACK</button>
        <button class="mode-btn" data-bg="1">NAVY</button>
        <button class="mode-btn" data-bg="2">PURPLE</button>
      </div>
    </div>
  </div>
</div>

<script type="module">
// ============================================================
// BODY PARTICLES — MediaPipe Pose × WebGPU Compute Particles
// ============================================================

import vision from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js';
const { PoseLandmarker, FilesetResolver } = vision;

const MAX_PARTICLES = 200000;
const WORKGROUP_SIZE = 256;

// Pose connections for skeleton drawing
const POSE_CONNECTIONS = [
  [0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],
  [9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],
  [17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],
  [11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],
  [27,29],[28,30],[29,31],[30,32],[27,31],[28,32]
];

// Joint weight multipliers (higher = more particles from this joint)
// Hands, wrists, elbows get more weight because they move more
const JOINT_WEIGHTS = new Float32Array(33);
for (let i = 0; i < 33; i++) JOINT_WEIGHTS[i] = 1.0;
// Wrists (15, 16)
JOINT_WEIGHTS[15] = 3.0; JOINT_WEIGHTS[16] = 3.0;
// Hands (17-22)
for (let i = 17; i <= 22; i++) JOINT_WEIGHTS[i] = 2.5;
// Elbows (13, 14)
JOINT_WEIGHTS[13] = 2.0; JOINT_WEIGHTS[14] = 2.0;

// Background colors
const BG_COLORS = [
  [0, 0, 0],           // BLACK
  [0.02, 0.02, 0.08],  // NAVY
  [0.05, 0.02, 0.08],  // PURPLE
];

// ---- WGSL Shaders ----

const computeShader = /* wgsl */`
struct Particle {
  pos: vec2<f32>,
  vel: vec2<f32>,
  life: f32,
  maxLife: f32,
  size: f32,
  jointIndex: f32,
};

struct Params {
  time: f32,
  deltaTime: f32,
  particleCount: f32,
  mode: f32,
  gravity: f32,
  particleSize: f32,
  canvasWidth: f32,
  canvasHeight: f32,
  frameCount: f32,
  colorTheme: f32,
  numActiveJoints: f32,
  pad: f32,
};

@group(0) @binding(0) var<storage, read> input: array<Particle>;
@group(0) @binding(1) var<storage, read_write> output: array<Particle>;
@group(0) @binding(2) var<storage, read> joints: array<vec4<f32>>;
@group(0) @binding(3) var<storage, read> jointActive: array<f32>;
@group(0) @binding(4) var<uniform> params: Params;

fn hash(seed: u32) -> f32 {
  var s = seed;
  s = s ^ (s >> 16u);
  s = s * 0x45d9f3bu;
  s = s ^ (s >> 16u);
  s = s * 0x45d9f3bu;
  s = s ^ (s >> 16u);
  return f32(s & 0x7fffffffu) / f32(0x7fffffff);
}

@compute @workgroup_size(${WORKGROUP_SIZE})
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let idx = gid.x;
  if (idx >= u32(params.particleCount)) { return; }

  var p = input[idx];
  let dt = params.deltaTime;
  let seed = idx * 17u + u32(params.frameCount) * 31u;

  // Respawn dead particles
  if (p.life <= 0.0 && params.numActiveJoints > 0.0) {
    let ji = u32(p.jointIndex) % 33u;

    if (jointActive[ji] > 0.5) {
      let jpos = joints[ji].xy;
      let jvel = joints[ji].zw;

      // Random offset
      let r1 = hash(seed + 100u);
      let r2 = hash(seed + 200u);
      let angle = r1 * 6.2831853;
      let radius = r2 * 0.015;

      p.pos = jpos + vec2<f32>(cos(angle), sin(angle)) * radius;

      // Mode-dependent initial velocity
      let r3 = hash(seed + 300u);
      let r4 = hash(seed + 400u);
      let dir = r3 * 6.2831853;
      let spd = r4;

      let mode = u32(params.mode);
      if (mode == 0u) {
        // AURA: soft spreading
        p.vel = vec2<f32>(cos(dir), sin(dir)) * spd * 0.12 + jvel * 2.0;
        p.maxLife = 1.5 + r4 * 1.5;
      } else if (mode == 1u) {
        // SPARK: fire sparks
        p.vel = vec2<f32>(cos(dir), sin(dir)) * spd * 0.5 + jvel * 3.0;
        p.maxLife = 0.3 + r4 * 0.7;
      } else {
        // TRAIL: ribbon trails
        p.vel = jvel * 3.5 + vec2<f32>(cos(dir), sin(dir)) * 0.015;
        p.maxLife = 2.5 + r4 * 2.5;
      }

      p.life = p.maxLife;
      p.size = 0.5 + hash(seed + 500u) * 1.0;
    }
  }

  // Physics update
  if (p.life > 0.0) {
    let mode = u32(params.mode);
    if (mode == 0u) {
      // AURA
      p.vel *= 0.985;
      p.vel.y -= params.gravity * 0.15 * dt;
      // Slight noise
      let n = hash(seed + u32(params.time * 100.0));
      p.vel += vec2<f32>(n - 0.5, hash(seed + 600u) - 0.5) * 0.01;
    } else if (mode == 1u) {
      // SPARK
      p.vel *= 0.97;
      p.vel.y += params.gravity * 0.8 * dt;
    } else {
      // TRAIL
      p.vel *= 0.93;
    }

    p.pos += p.vel * dt;
    p.life -= dt;

    if (p.life <= 0.0) {
      p.life = 0.0;
      // Reassign to random joint
      let newJoint = hash(seed + 700u) * 33.0;
      p.jointIndex = floor(newJoint);
    }
  }

  output[idx] = p;
}
`;

const renderShader = /* wgsl */`
struct Particle {
  pos: vec2<f32>,
  vel: vec2<f32>,
  life: f32,
  maxLife: f32,
  size: f32,
  jointIndex: f32,
};

struct RParams {
  aspect: f32,
  baseSize: f32,
  colorTheme: f32,
  time: f32,
};

@group(0) @binding(0) var<storage, read> particles: array<Particle>;
@group(0) @binding(1) var<uniform> rp: RParams;

struct VSOut {
  @builtin(position) pos: vec4<f32>,
  @location(0) uv: vec2<f32>,
  @location(1) lifeRatio: f32,
  @location(2) @interpolate(flat) jointIdx: u32,
};

fn hsv2rgb(h: f32, s: f32, v: f32) -> vec3<f32> {
  let hh = fract(h) * 6.0;
  let i = floor(hh);
  let f = hh - i;
  let pp = v * (1.0 - s);
  let q = v * (1.0 - s * f);
  let t = v * (1.0 - s * (1.0 - f));
  var rgb: vec3<f32>;
  if (i < 1.0) { rgb = vec3<f32>(v, t, pp); }
  else if (i < 2.0) { rgb = vec3<f32>(q, v, pp); }
  else if (i < 3.0) { rgb = vec3<f32>(pp, v, t); }
  else if (i < 4.0) { rgb = vec3<f32>(pp, q, v); }
  else if (i < 5.0) { rgb = vec3<f32>(t, pp, v); }
  else { rgb = vec3<f32>(v, pp, q); }
  return rgb;
}

// Joint side: 0=left(warm), 1=right(cool), 2=center
fn getJointSide(idx: u32) -> u32 {
  // Center: nose(0), left/right eye inner(1,4) mapped differently
  // Left body (landmarks on user's left = indices 1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31)
  // Right body (landmarks on user's right = indices 4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32)
  if (idx == 0u || idx == 9u || idx == 10u) { return 2u; } // nose, mouth
  // Left side: odd indices for face (1,2,3), then specific body parts
  if (idx == 1u || idx == 2u || idx == 3u || idx == 7u ||
      idx == 11u || idx == 13u || idx == 15u || idx == 17u || idx == 19u || idx == 21u ||
      idx == 23u || idx == 25u || idx == 27u || idx == 29u || idx == 31u) {
    return 0u;
  }
  return 1u;
}

@vertex
fn vs_main(
  @builtin(vertex_index) vid: u32,
  @builtin(instance_index) iid: u32,
) -> VSOut {
  let qx = f32(vid & 1u) * 2.0 - 1.0;
  let qy = f32((vid >> 1u) & 1u) * 2.0 - 1.0;

  let p = particles[iid];

  var out: VSOut;

  if (p.life <= 0.0) {
    out.pos = vec4<f32>(10.0, 10.0, 0.0, 1.0);
    out.uv = vec2<f32>(0.0);
    out.lifeRatio = 0.0;
    out.jointIdx = 0u;
    return out;
  }

  let lifeRatio = p.life / p.maxLife;
  // Size: born large, fade small
  let sizeScale = 0.3 + lifeRatio * 0.7;
  let size = rp.baseSize / 900.0 * p.size * sizeScale;

  // Map pos (0..1 range) to clip space (-1..1)
  var screenPos = p.pos * 2.0 - 1.0;
  // Flip Y because screen Y is top-down but clip space Y is bottom-up
  screenPos.y = -screenPos.y;
  screenPos += vec2<f32>(qx, qy) * size;
  screenPos.x /= rp.aspect;

  out.pos = vec4<f32>(screenPos, 0.0, 1.0);
  out.uv = vec2<f32>(qx, qy);
  out.lifeRatio = lifeRatio;
  out.jointIdx = u32(p.jointIndex);
  return out;
}

@fragment
fn fs_main(in: VSOut) -> @location(0) vec4<f32> {
  let dist = length(in.uv);
  if (dist > 1.0) { discard; }

  let glow = exp(-dist * dist * 3.0);
  let side = getJointSide(in.jointIdx);
  let ji = f32(in.jointIdx);
  let theme = u32(rp.colorTheme);

  var hue: f32;
  var sat: f32;

  if (theme == 0u) {
    // NEON
    if (side == 0u) { hue = 0.0 + ji * 0.004; sat = 0.85; }
    else if (side == 1u) { hue = 0.55 + ji * 0.004; sat = 0.85; }
    else { hue = 0.85; sat = 0.4; }
  } else if (theme == 1u) {
    // FIRE
    if (side == 0u) { hue = 0.0 + ji * 0.003; sat = 0.9; }
    else if (side == 1u) { hue = 0.05 + ji * 0.004; sat = 0.85; }
    else { hue = 0.08; sat = 0.3; }
  } else if (theme == 2u) {
    // ICE
    if (side == 0u) { hue = 0.55 + ji * 0.003; sat = 0.7; }
    else if (side == 1u) { hue = 0.65 + ji * 0.004; sat = 0.75; }
    else { hue = 0.6; sat = 0.2; }
  } else {
    // RAINBOW
    hue = ji / 33.0;
    sat = 0.8;
  }

  sat *= in.lifeRatio;
  let val = in.lifeRatio;
  let color = hsv2rgb(hue, sat, val);
  let alpha = glow * in.lifeRatio * 0.5;

  return vec4<f32>(color * alpha, alpha);
}
`;

// ============================================================
// Main
// ============================================================

async function main() {
  const errorScreen = document.getElementById('error-screen');
  const startScreen = document.getElementById('start-screen');
  const startBtn = document.getElementById('start-btn');
  const loadingStatus = document.getElementById('loading-status');
  const titleBar = document.getElementById('title-bar');
  const previewWrap = document.getElementById('preview-wrap');
  const hintEl = document.getElementById('hint');
  const controlsEl = document.getElementById('controls');

  // Check WebGPU
  if (!navigator.gpu) {
    startScreen.classList.remove('active');
    errorScreen.style.display = 'flex';
    return;
  }

  loadingStatus.textContent = 'INITIALIZING WebGPU...';

  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) {
    startScreen.classList.remove('active');
    errorScreen.style.display = 'flex';
    return;
  }

  const device = await adapter.requestDevice();

  // Canvas setup
  const canvas = document.getElementById('gpuCanvas');
  const gpuCtx = canvas.getContext('webgpu');
  const format = navigator.gpu.getPreferredCanvasFormat();
  const dpr = Math.min(window.devicePixelRatio || 1, 2);

  function resize() {
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
  }
  resize();

  gpuCtx.configure({ device, format, alphaMode: 'opaque' });

  // ---- Load MediaPipe ----
  loadingStatus.textContent = 'LOADING POSE LANDMARKER MODEL...';

  let poseLandmarker;
  try {
    const filesetResolver = await FilesetResolver.forVisionTasks(
      'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm'
    );
    poseLandmarker = await PoseLandmarker.createFromOptions(filesetResolver, {
      baseOptions: {
        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task',
        delegate: 'GPU'
      },
      runningMode: 'VIDEO',
      numPoses: 1
    });
  } catch (e) {
    console.error('MediaPipe load error:', e);
    loadingStatus.textContent = 'ERROR: FAILED TO LOAD POSE MODEL';
    return;
  }

  loadingStatus.textContent = 'SYSTEMS READY';
  startBtn.textContent = 'START CAMERA';
  startBtn.disabled = false;

  // ---- State ----
  let currentMode = 0;  // 0=AURA, 1=SPARK, 2=TRAIL
  let colorTheme = 0;   // 0=NEON, 1=FIRE, 2=ICE, 3=RAINBOW
  let bgIndex = 0;
  let particleCount = MAX_PARTICLES;
  let particleSizeVal = 2.0;
  let gravityVal = 0.5;
  let uiVisible = true;
  let prevLandmarks = new Float32Array(33 * 2);
  let hasDetection = false;
  let frameCount = 0;

  // ---- Create GPU buffers ----
  const FLOATS_PER_PARTICLE = 8;
  const BYTES_PER_PARTICLE = FLOATS_PER_PARTICLE * 4;
  const particleByteSize = MAX_PARTICLES * BYTES_PER_PARTICLE;

  // Initialize particles: all dead, random joint assignment
  const initData = new Float32Array(MAX_PARTICLES * FLOATS_PER_PARTICLE);
  for (let i = 0; i < MAX_PARTICLES; i++) {
    const idx = i * FLOATS_PER_PARTICLE;
    initData[idx + 0] = Math.random(); // x (0-1 range)
    initData[idx + 1] = Math.random(); // y
    initData[idx + 2] = 0; // vx
    initData[idx + 3] = 0; // vy
    initData[idx + 4] = 0; // life (dead)
    initData[idx + 5] = 0; // maxLife
    initData[idx + 6] = 1; // size
    initData[idx + 7] = Math.floor(Math.random() * 33); // jointIndex
  }

  const particleBuffers = [0, 1].map(() =>
    device.createBuffer({
      size: particleByteSize,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    })
  );
  device.queue.writeBuffer(particleBuffers[0], 0, initData);
  device.queue.writeBuffer(particleBuffers[1], 0, initData);

  // Joint data buffer: 33 joints × vec4(x, y, vx, vy) = 528 bytes
  const jointDataBuffer = device.createBuffer({
    size: 33 * 16,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });

  // Joint active mask: 64 floats (padded)
  const jointActiveBuffer = device.createBuffer({
    size: 64 * 4,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });

  // Params uniform: 12 floats = 48 bytes
  const paramsBuffer = device.createBuffer({
    size: 48,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  // Render uniform: 4 floats = 16 bytes
  const renderUniformBuffer = device.createBuffer({
    size: 16,
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
  });

  // ---- Pipelines ----
  const computePipeline = device.createComputePipeline({
    layout: 'auto',
    compute: {
      module: device.createShaderModule({ code: computeShader }),
      entryPoint: 'main',
    },
  });

  const particlePipeline = device.createRenderPipeline({
    layout: 'auto',
    vertex: {
      module: device.createShaderModule({ code: renderShader }),
      entryPoint: 'vs_main',
    },
    fragment: {
      module: device.createShaderModule({ code: renderShader }),
      entryPoint: 'fs_main',
      targets: [{
        format,
        blend: {
          color: { srcFactor: 'src-alpha', dstFactor: 'one', operation: 'add' },
          alpha: { srcFactor: 'one', dstFactor: 'one', operation: 'add' },
        },
      }],
    },
    primitive: { topology: 'triangle-strip' },
  });

  // ---- Bind groups (ping-pong) ----
  const computeBindGroups = [0, 1].map(i =>
    device.createBindGroup({
      layout: computePipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: particleBuffers[i] } },
        { binding: 1, resource: { buffer: particleBuffers[1 - i] } },
        { binding: 2, resource: { buffer: jointDataBuffer } },
        { binding: 3, resource: { buffer: jointActiveBuffer } },
        { binding: 4, resource: { buffer: paramsBuffer } },
      ],
    })
  );

  const renderBindGroups = [0, 1].map(i =>
    device.createBindGroup({
      layout: particlePipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: particleBuffers[i] } },
        { binding: 1, resource: { buffer: renderUniformBuffer } },
      ],
    })
  );

  // ---- Camera preview canvas ----
  const previewCanvas = document.getElementById('preview-canvas');
  const previewCtx = previewCanvas.getContext('2d');

  // ---- Start camera ----
  let video;

  startBtn.addEventListener('click', async () => {
    startBtn.disabled = true;
    startBtn.textContent = 'ACCESSING CAMERA...';

    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } }
      });

      video = document.createElement('video');
      video.srcObject = stream;
      video.setAttribute('playsinline', '');
      video.muted = true;

      // Wait for video metadata before reading dimensions
      await new Promise((resolve) => {
        video.onloadedmetadata = resolve;
      });
      await video.play();

      // Set preview canvas dimensions
      const vw = video.videoWidth || 1280;
      const vh = video.videoHeight || 720;
      const aspect = vw / vh;
      previewCanvas.width = 200;
      previewCanvas.height = Math.round(200 / aspect);

      // Show main UI
      startScreen.classList.remove('active');
      titleBar.classList.remove('hidden');
      previewWrap.classList.remove('hidden');
      hintEl.classList.remove('hidden');
      controlsEl.classList.remove('hidden');

      // Start animation
      requestAnimationFrame(animate);

    } catch (e) {
      console.error('Camera error:', e);
      startBtn.textContent = 'CAMERA ACCESS DENIED';
      loadingStatus.textContent = 'Please allow camera access and reload';
    }
  });

  // ---- Resize handler ----
  window.addEventListener('resize', () => {
    resize();
    gpuCtx.configure({ device, format, alphaMode: 'opaque' });
  });

  // ---- Controls ----
  const modeNames = ['AURA', 'SPARK', 'TRAIL'];
  const modeLabelEl = document.getElementById('mode-label');

  function setMode(m) {
    currentMode = m;
    modeLabelEl.textContent = modeNames[m];
    document.querySelectorAll('#mode-btns .mode-btn').forEach((b, i) => {
      b.classList.toggle('active', i === m);
    });
  }

  document.querySelectorAll('#mode-btns .mode-btn').forEach(btn => {
    btn.addEventListener('click', () => setMode(parseInt(btn.dataset.mode)));
  });

  document.querySelectorAll('#color-btns .mode-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      colorTheme = parseInt(btn.dataset.color);
      document.querySelectorAll('#color-btns .mode-btn').forEach((b, i) => {
        b.classList.toggle('active', i === colorTheme);
      });
    });
  });

  document.querySelectorAll('#bg-btns .mode-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      bgIndex = parseInt(btn.dataset.bg);
      document.querySelectorAll('#bg-btns .mode-btn').forEach((b, i) => {
        b.classList.toggle('active', i === bgIndex);
      });
    });
  });

  const particleSlider = document.getElementById('particle-slider');
  const particleLabel = document.getElementById('particle-count-label');
  particleSlider.addEventListener('input', () => {
    particleCount = parseInt(particleSlider.value);
    particleLabel.textContent = (particleCount / 1000) + 'K';
  });

  document.getElementById('size-slider').addEventListener('input', (e) => {
    particleSizeVal = parseFloat(e.target.value);
  });
  document.getElementById('gravity-slider').addEventListener('input', (e) => {
    gravityVal = parseFloat(e.target.value);
  });

  // Collapse toggle
  document.getElementById('ctrl-toggle').addEventListener('click', () => {
    controlsEl.classList.toggle('collapsed');
  });

  // Keyboard
  window.addEventListener('keydown', (e) => {
    if (e.key === '1') setMode(0);
    else if (e.key === '2') setMode(1);
    else if (e.key === '3') setMode(2);
    else if (e.key === ' ') {
      e.preventDefault();
      // Reset all particles
      device.queue.writeBuffer(particleBuffers[0], 0, initData);
      device.queue.writeBuffer(particleBuffers[1], 0, initData);
    } else if (e.key === 'h' || e.key === 'H') {
      uiVisible = !uiVisible;
      titleBar.classList.toggle('hidden', !uiVisible);
      previewWrap.classList.toggle('hidden', !uiVisible);
      controlsEl.classList.toggle('hidden', !uiVisible);
    }
  });

  // Click/tap to cycle mode
  canvas.addEventListener('click', () => {
    setMode((currentMode + 1) % 3);
  });

  // ---- Animation loop ----
  let lastTime = performance.now();
  let fpsAccum = 0, fpsCount = 0;
  const fpsEl = document.getElementById('fps');

  function animate(now) {
    requestAnimationFrame(animate);

    const dt = Math.min((now - lastTime) / 1000, 0.05);
    lastTime = now;
    const time = now / 1000;

    // FPS
    fpsAccum += dt;
    fpsCount++;
    if (fpsAccum >= 0.5) {
      fpsEl.textContent = `${Math.round(fpsCount / fpsAccum)} FPS`;
      fpsAccum = 0;
      fpsCount = 0;
    }

    // ---- MediaPipe detection ----
    let landmarks = null;
    if (video && video.readyState >= 2) {
      try {
        const results = poseLandmarker.detectForVideo(video, now);
        if (results.landmarks && results.landmarks.length > 0) {
          landmarks = results.landmarks[0];
          hasDetection = true;
          hintEl.style.opacity = '0';
        } else {
          hasDetection = false;
          hintEl.style.opacity = '1';
        }
      } catch (e) {
        // Skip frame on detection error
      }
    }

    // ---- Update joint data ----
    const jointData = new Float32Array(33 * 4);
    const activeData = new Float32Array(64);
    let numActive = 0;

    if (landmarks) {
      for (let i = 0; i < 33; i++) {
        const lm = landmarks[i];
        const x = 1.0 - lm.x; // Mirror for user-facing camera
        const y = lm.y;
        const vis = lm.visibility || 0;

        const vx = x - prevLandmarks[i * 2];
        const vy = y - prevLandmarks[i * 2 + 1];

        jointData[i * 4 + 0] = x;
        jointData[i * 4 + 1] = y;
        jointData[i * 4 + 2] = vx;
        jointData[i * 4 + 3] = vy;

        prevLandmarks[i * 2] = x;
        prevLandmarks[i * 2 + 1] = y;

        if (vis > 0.5) {
          activeData[i] = JOINT_WEIGHTS[i];
          numActive++;
        }
      }
    }

    device.queue.writeBuffer(jointDataBuffer, 0, jointData);
    device.queue.writeBuffer(jointActiveBuffer, 0, activeData);

    // ---- Update params ----
    const aspect = canvas.width / canvas.height;
    const paramsData = new Float32Array([
      time, dt, particleCount, currentMode,
      gravityVal, particleSizeVal, canvas.width, canvas.height,
      frameCount, colorTheme, numActive, 0,
    ]);
    device.queue.writeBuffer(paramsBuffer, 0, paramsData);

    const renderData = new Float32Array([aspect, particleSizeVal, colorTheme, time]);
    device.queue.writeBuffer(renderUniformBuffer, 0, renderData);

    // ---- GPU passes ----
    const pingPong = frameCount % 2;
    const encoder = device.createCommandEncoder();

    // Compute pass
    const computePass = encoder.beginComputePass();
    computePass.setPipeline(computePipeline);
    computePass.setBindGroup(0, computeBindGroups[pingPong]);
    computePass.dispatchWorkgroups(Math.ceil(particleCount / WORKGROUP_SIZE));
    computePass.end();

    // Render pass
    const bg = BG_COLORS[bgIndex];
    const canvasView = gpuCtx.getCurrentTexture().createView();
    const renderPass = encoder.beginRenderPass({
      colorAttachments: [{
        view: canvasView,
        loadOp: 'clear',
        clearValue: { r: bg[0], g: bg[1], b: bg[2], a: 1 },
        storeOp: 'store',
      }],
    });

    renderPass.setPipeline(particlePipeline);
    renderPass.setBindGroup(0, renderBindGroups[1 - pingPong]);
    renderPass.draw(4, particleCount);
    renderPass.end();

    device.queue.submit([encoder.finish()]);

    // ---- Camera preview with skeleton ----
    if (video && video.readyState >= 2 && uiVisible) {
      const pw = previewCanvas.width;
      const ph = previewCanvas.height;

      previewCtx.save();
      previewCtx.scale(-1, 1);
      previewCtx.drawImage(video, -pw, 0, pw, ph);
      previewCtx.restore();

      // Draw skeleton
      if (landmarks) {
        const pts = landmarks.map(lm => ({
          x: (1 - lm.x) * pw,
          y: lm.y * ph,
          v: lm.visibility || 0
        }));

        // Connections
        previewCtx.strokeStyle = 'rgba(255,255,255,0.4)';
        previewCtx.lineWidth = 1.5;
        for (const [a, b] of POSE_CONNECTIONS) {
          if (a >= pts.length || b >= pts.length) continue;
          if (pts[a].v < 0.4 || pts[b].v < 0.4) continue;
          previewCtx.beginPath();
          previewCtx.moveTo(pts[a].x, pts[a].y);
          previewCtx.lineTo(pts[b].x, pts[b].y);
          previewCtx.stroke();
        }

        // Joint dots
        for (const pt of pts) {
          if (pt.v < 0.4) continue;
          previewCtx.fillStyle = 'rgba(255,100,100,0.8)';
          previewCtx.beginPath();
          previewCtx.arc(pt.x, pt.y, 2.5, 0, Math.PI * 2);
          previewCtx.fill();
        }
      }
    }

    frameCount++;
  }
}

main().catch(err => {
  console.error(err);
  document.getElementById('start-screen').classList.remove('active');
  document.getElementById('error-screen').style.display = 'flex';
});
</script>
</body>
</html>
